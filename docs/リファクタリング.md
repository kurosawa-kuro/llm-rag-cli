承知しました。いまの設計は「機能は揃っている」ので、次は **“保守できる形” に寄せる**のが正解です。下に、CLI型RAGを崩さずに進められるリファクタリング方針と、具体的な作業順（壊しにくい順）をまとめます。

---

## 1) リファクタリングのゴール（コード整理の軸）

優先順位はこの順が安全です。

1. **境界をはっきりさせる**

   * “ドメイン(状態/結果)” と “外部(LLM/DB/モデル)” を分離
2. **依存を注入できる形にする**（テスト容易性UP）

   * 「シングルトンを捨てる」のではなく、まず “コンテナ/ファクトリ経由” に寄せる
3. **I/O と純粋ロジックを分ける**

   * ingest/ask のCLIは薄く、内部は関数・クラスに寄せる
4. **型とデータ構造を固定する**

   * dictの多用をやめ、`dataclass` / `TypedDict` / `pydantic` を導入
5. **ログ/例外/設定**の一貫性を取る

   * “print” ではなく “logger”、例外は握りつぶさない

---

## 2) まずやるべき「構造」整理（フォルダ・責務）

いまの `app/` は良いですが、**責務単位でサブパッケージ化**すると急に読みやすくなります。

例（おすすめ）:

```text
app/
  __init__.py
  cli/
    ingest_cli.py
    ask_cli.py
    evaluate_cli.py
  core/
    config.py
    types.py          # RAGState, SearchResult 等の型
    errors.py
    logging.py
  infra/
    db.py
    embeddings.py
    llm.py
    reranker.py
  pipeline/
    chunking.py
    ingest.py
    retrieval.py      # vector search
    prompting.py      # prompt builder
    graph.py
  eval/
    metrics.py
    evaluate.py
```

* `cli/` は **引数解析して呼ぶだけ**
* `infra/` は **重い依存（DB/モデル）**
* `pipeline/` は **処理ロジック**
* `core/` は **共通（設定/型/例外/ログ）**

この分離だけで「どこを触ると何が壊れるか」が激減します。

---

## 3) シングルトンの“扱い”を変える（捨てずに改善）

現状の `_llm` `_embeddings` `_vectorstore` は実用上OKです。
ただし **import時点で副作用が出やすい**のが欠点なので、次に寄せると安定します。

### 推奨：AppContainer（簡易DI）を導入

* “必要なときに初期化” は維持
* グローバル変数は container の中に閉じ込める
* テストは container を差し替えるだけで済む

イメージ（方針）:

* `core/container.py` を作り、`get_llm()` 等を **containerメソッド**へ移動
* `graph.py` や `ask.py` は container を受け取る（依存注入）

> これで「シングルトンが散らばっていて追えない」が解消します。

---

## 4) 状態・戻り値を “dict” から型へ（壊れる前に固定）

いま一番事故りやすいのはここです。

### 4.1 Search結果の型を固定

`ask.search()` が返す `list[dict]` は、フィールド欠損で壊れやすいので、まずこれを固定。

* `SearchHit(content: str, source: str, score: float | None, metadata: dict)` など
* rerank も `List[Document]` or `List[SearchHit]` のどちらかに統一

### 4.2 RAGStateをdataclass化

LangGraphのstateは dict でも動きますが、**開発体験が段違い**になります。

* `@dataclass` で `query, documents, reranked_documents, contexts, prompt, answer, sources`
* ノードは「Stateを受けて Stateを返す」だけに統一

---

## 5) graphノードを “純粋関数” に寄せる（テスト最強化）

今の `retrieve/rerank/generate` は責務が明確なので、次の形が理想です。

* ノード内で `get_llm()` とかを呼ばない
* 依存は外から渡す（container経由でもOK）

例：

* `retrieve(state, retriever) -> state`
* `rerank(state, reranker) -> state`
* `generate(state, llm, prompt_builder) -> state`

これでテストが「モックを渡すだけ」になり、テスト量も減らせます（250件を維持しつつ保守性UP）。

---

## 6) Prompt組み立てを独立させる（改良が速くなる）

`generate_node` にベタ書きされやすいので、ここを分離すると “回答品質改善” の実験がしやすいです。

* `pipeline/prompting.py`

  * `build_prompt(query: str, contexts: list[str]) -> str`
  * “ソースの出し方”“引用ルール”“不足時の返答” をここで一元管理

---

## 7) ingestの責務分解（次の拡張が楽）

`ingest.py` はやりがちですが肥大化しやすいので、次で分けると拡張に強いです。

* `loaders/`（または `pipeline/ingest.py` 内で関数分割）

  * `load_pdf_pages()`
  * `load_csv_rows()`
* `chunkers/`

  * `chunk_pdf_text()`
  * `chunk_csv_text()`
* `writers/`

  * `add_documents(vectorstore, docs)`

「PDFだけ処理したい」「CSVだけ差分取り込み」みたいな機能追加がほぼ無料になります。

---

## 8) 設定管理を “pydantic settings” に寄せる（環境変数地獄を終わらせる）

`config.py` の `get_db_config()` は正しい方向性です。次の段階は：

* `RagSettings`（pydantic）で `int` パース・デフォルト・バリデーションを一本化
* 例：`CHUNK_OVERLAP >= 0`, `CHUNK_SIZE > 0`, `RERANK_TOP_K <= SEARCH_K` など

設定の整合性を起動時に検証できるようになります。

---

## 9) “ログ” と “例外” を統一（運用のため）

CPU推論 + pgvector は、詰まると原因が見えにくいです。

* `core/logging.py` を作り `logger = logging.getLogger("rag")`
* 主要イベントだけinfoで出す（例：ingest件数、検索件数、rerank件数、生成トークン上限など）
* 例外は握りつぶさず、CLI層で整形して終了コードを返す

  * `core/errors.py` に `RagError` を作り、外部例外は `raise RagError(...) from e`

---

## 10) 実行順ロードマップ（壊しにくい順）

この順でやると安全です（テストが通り続けやすい）。

1. **フォルダ再編（cli/core/infra/pipeline/eval）**：importパス調整のみ
2. **prompting.py 分離**：generate_nodeから切り出す
3. **Search結果の型固定**（TypedDict → dataclassへ）
4. **RAGState dataclass化**（LangGraph stateの受け渡しを統一）
5. **container導入**（重い依存を集約）
6. **graphノード純粋関数化**（依存を引数へ）
7. **pydantic settings導入**（設定の検証含む）
8. **ログ/例外の統一**
9. **ingest責務分割**（差分取り込み等の拡張に備える）

---

## 11) 仕上げの“品質”改善（任意だが効く）

* `make lint` を `ruff` + `mypy` に置き換える（構文チェック以上に効く）
* テストの重複を減らす：

  * “ノード単体テスト” と “E2E（モック）” の2層に整理
* `Document` のメタデータキーは定数化（`SOURCE_KEY = "source"` など）

