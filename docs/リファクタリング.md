了解です。**重要箇所だけ**（追加/変更が必要なファイル断片）を、コピペで進められる形で出します。
前提：いまの `AppContainer` / `graph.py` は Container+DI 済み。

---

# 1) Protocol 完全実装（重要箇所）

## 1-1. `app/interfaces.py`（新規）

> LangChainに寄りすぎない「最小境界」。ここが“型の防波堤”。

```python
from __future__ import annotations

from typing import Protocol, List, Callable, Any
from langchain_core.documents import Document


class RetrieverProtocol(Protocol):
    def invoke(self, query: str) -> List[Document]: ...


class VectorStoreProtocol(Protocol):
    def as_retriever(self, *, search_kwargs: dict) -> RetrieverProtocol: ...


class RerankerProtocol(Protocol):
    # CrossEncoderReranker の戻りが Iterable の場合もあるので List[Document] に寄せる
    def compress_documents(self, documents: List[Document], query: str) -> List[Document]: ...


class LLMProtocol(Protocol):
    def invoke(self, prompt: str) -> str: ...


PromptBuilder = Callable[[str, List[str]], str]


class RetrievalStrategyProtocol(Protocol):
    def retrieve(self, query: str) -> List[Document]: ...
```

---

## 1-2. `app/container.py`（重要箇所の差分）

> container のプロパティ戻り値を Protocol で固定し、IDE補完 & 差し替え安全性を上げます。
> （既に `create_*` で統合済みの想定）

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional

from app.interfaces import (
    VectorStoreProtocol,
    RerankerProtocol,
    LLMProtocol,
    PromptBuilder,
    RetrievalStrategyProtocol,
)
from app.db import create_vectorstore
from app.embeddings import create_embeddings
from app.reranker import create_reranker
from app.llm import create_llm
from app.prompting import build_prompt


@dataclass(frozen=True)
class RagSettings:
    search_k: int
    rerank_top_k: int


class AppContainer:
    def __init__(
        self,
        *,
        settings: RagSettings,
        embeddings=None,         # 型固定したければ Protocol 追加可（今回は省略）
        vectorstore: VectorStoreProtocol | None = None,
        reranker: RerankerProtocol | None = None,
        llm: LLMProtocol | None = None,
        prompt_builder: PromptBuilder | None = None,
        retrieval_strategy: RetrievalStrategyProtocol | None = None,
    ):
        self.settings = settings
        self._embeddings = embeddings
        self._vectorstore = vectorstore
        self._reranker = reranker
        self._llm = llm
        self._prompt_builder = prompt_builder
        self._retrieval_strategy = retrieval_strategy

    @property
    def embeddings(self):
        if self._embeddings is None:
            self._embeddings = create_embeddings()
        return self._embeddings

    @property
    def vectorstore(self) -> VectorStoreProtocol:
        if self._vectorstore is None:
            self._vectorstore = create_vectorstore(self.embeddings)
        return self._vectorstore

    @property
    def reranker(self) -> RerankerProtocol:
        if self._reranker is None:
            self._reranker = create_reranker()
        return self._reranker

    @property
    def llm(self) -> LLMProtocol:
        if self._llm is None:
            self._llm = create_llm()
        return self._llm

    @property
    def prompt_builder(self) -> PromptBuilder:
        return self._prompt_builder or build_prompt

    @property
    def retrieval_strategy(self) -> RetrievalStrategyProtocol:
        # ここは次セクションで実装する TwoStageRetrieval を使う
        if self._retrieval_strategy is None:
            from app.retrieval import TwoStageRetrieval  # 循環import回避

            self._retrieval_strategy = TwoStageRetrieval(
                vectorstore=self.vectorstore,
                reranker=self.reranker,
                search_k=self.settings.search_k,
                rerank_top_k=self.settings.rerank_top_k,
            )
        return self._retrieval_strategy
```

---

# 2) RetrievalStrategy 完全実装（重要箇所）

## 2-1. `app/retrieval.py`（新規：Two-Stage Retrieval を一箇所に閉じ込める）

> graph から “検索とリランキングの詳細” を追い出します。
> 将来、BM25やHybrid、MMR、RRFに差し替えやすくなります。

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import List
from langchain_core.documents import Document

from app.interfaces import VectorStoreProtocol, RerankerProtocol


@dataclass(frozen=True)
class TwoStageRetrieval:
    vectorstore: VectorStoreProtocol
    reranker: RerankerProtocol
    search_k: int
    rerank_top_k: int

    def retrieve(self, query: str) -> List[Document]:
        # 1st stage: vector search
        retriever = self.vectorstore.as_retriever(search_kwargs={"k": self.search_k})
        docs = retriever.invoke(query) or []
        if not docs:
            return []

        # 2nd stage: rerank
        reranked = self.reranker.compress_documents(list(docs), query) or []
        return list(reranked[: self.rerank_top_k])
```

---

## 2-2. `app/graph.py`（重要箇所の置換：retrieve/rerank を strategy に統一）

> ノード構成は維持しつつ、retrieve と rerank を “実質1つ” に寄せます。
> （※ノードは3つのままでもOK。ログ/計測のために分けたいなら分割版も可能）

### 置換案A：retrieveノードで TwoStage をまとめて実行（シンプル）

```python
def create_retrieve(container: AppContainer):
    def retrieve(state: RAGState) -> RAGState:
        # TwoStageRetrieval が rerank までやる
        state.reranked_documents = container.retrieval_strategy.retrieve(state.query)
        return state
    return retrieve


def create_generate(container: AppContainer):
    def generate_node(state: RAGState) -> RAGState:
        docs = state.reranked_documents
        if not docs:
            state.answer = "関連情報が見つかりませんでした。"
            state.sources = []
            state.contexts = []
            state.prompt = ""
            return state

        state.contexts = [d.page_content for d in docs]

        # source重複排除
        seen = set()
        sources = []
        for d in docs:
            s = (d.metadata or {}).get("source", "") or ""
            if s and s not in seen:
                seen.add(s)
                sources.append(s)
        state.sources = sources

        state.prompt = container.prompt_builder(state.query, state.contexts)
        state.answer = container.llm.invoke(state.prompt)
        return state
    return generate_node
```

グラフは「retrieve → generate」でも良いですが、現状維持なら：

* `retrieve`（TwoStageを実行）
* `generate`

の2ノードへ整理できます（評価/計測が楽）。

---

### 置換案B：ノードを3つのまま残す（計測/ログ重視）

* `retrieve`：vector候補だけ取得して `state.documents`
* `rerank`：strategyの内部関数を呼ぶ or rerankerのみ
* `generate`：同じ

ただ、**“完全実装”の意図（責務分離）**なら A が一番きれいです。

---

# 3) これで達成できる状態

* `interfaces.py` が境界（LangChain差し替えの防波堤）
* `retrieval.py` が検索戦略の中心（TwoStageを完全カプセル化）
* `graph.py` は **オーケストレーションだけ**（薄く保てる）
* container だけが依存を知る

---

必要なら次の一手として、同じパターンで：

* `GenerationStrategy`（プロンプト組み立て＋LLM呼び出し＋後処理）
* `SourceFormatter`（sourcesの出し方、引用ルール）

まで分離すると、さらに拡張が安全になります。
